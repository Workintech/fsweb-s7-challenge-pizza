{"ast":null,"code":"import dedent from \"ts-dedent\";\nimport { l as log } from \"./config-389b86ff.js\";\nimport { i as isDetailedError, u as utils, r as registerLazyLoadedDiagrams, l as loadRegisteredDiagrams } from \"./utils-d5eeff82.js\";\nimport { m as mermaidAPI } from \"./mermaidAPI-0716c7c2.js\";\nimport \"dompurify\";\nimport \"dayjs\";\nimport \"khroma\";\nimport \"@braintree/sanitize-url\";\nimport \"d3\";\nimport \"./setupGraphViewbox-e35e4124.js\";\nimport \"./commonDb-2ace122b.js\";\nimport \"lodash-es/memoize.js\";\nimport \"stylis\";\nimport \"./errorRenderer-d05351b9.js\";\nimport \"lodash-es/isEmpty.js\";\nconst handleError = (error, errors, parseError) => {\n  log.warn(error);\n  if (isDetailedError(error)) {\n    if (parseError) {\n      parseError(error.str, error.hash);\n    }\n    errors.push({\n      ...error,\n      message: error.str,\n      error\n    });\n  } else {\n    if (parseError) {\n      parseError(error);\n    }\n    if (error instanceof Error) {\n      errors.push({\n        str: error.message,\n        message: error.message,\n        hash: error.name,\n        error\n      });\n    }\n  }\n};\nconst run = async function (options = {\n  querySelector: \".mermaid\"\n}) {\n  try {\n    await runThrowsErrors(options);\n  } catch (e) {\n    if (isDetailedError(e)) {\n      log.error(e.str);\n    }\n    if (mermaid.parseError) {\n      mermaid.parseError(e);\n    }\n    if (!options.suppressErrors) {\n      log.error(\"Use the suppressErrors option to suppress these errors\");\n      throw e;\n    }\n  }\n};\nconst runThrowsErrors = async function ({\n  postRenderCallback,\n  querySelector,\n  nodes\n} = {\n  querySelector: \".mermaid\"\n}) {\n  const conf = mermaidAPI.getConfig();\n  log.debug(`${!postRenderCallback ? \"No \" : \"\"}Callback function found`);\n  let nodesToProcess;\n  if (nodes) {\n    nodesToProcess = nodes;\n  } else if (querySelector) {\n    nodesToProcess = document.querySelectorAll(querySelector);\n  } else {\n    throw new Error(\"Nodes and querySelector are both undefined\");\n  }\n  log.debug(`Found ${nodesToProcess.length} diagrams`);\n  if ((conf == null ? void 0 : conf.startOnLoad) !== void 0) {\n    log.debug(\"Start On Load: \" + (conf == null ? void 0 : conf.startOnLoad));\n    mermaidAPI.updateSiteConfig({\n      startOnLoad: conf == null ? void 0 : conf.startOnLoad\n    });\n  }\n  const idGenerator = new utils.initIdGenerator(conf.deterministicIds, conf.deterministicIDSeed);\n  let txt;\n  const errors = [];\n  for (const element of Array.from(nodesToProcess)) {\n    log.info(\"Rendering diagram: \" + element.id);\n    /*! Check if previously processed */\n    if (element.getAttribute(\"data-processed\")) {\n      continue;\n    }\n    element.setAttribute(\"data-processed\", \"true\");\n    const id = `mermaid-${idGenerator.next()}`;\n    txt = element.innerHTML;\n    txt = dedent(utils.entityDecode(txt)).trim().replace(/<br\\s*\\/?>/gi, \"<br/>\");\n    const init2 = utils.detectInit(txt);\n    if (init2) {\n      log.debug(\"Detected early reinit: \", init2);\n    }\n    try {\n      const {\n        svg,\n        bindFunctions\n      } = await render(id, txt, element);\n      element.innerHTML = svg;\n      if (postRenderCallback) {\n        await postRenderCallback(id);\n      }\n      if (bindFunctions) {\n        bindFunctions(element);\n      }\n    } catch (error) {\n      handleError(error, errors, mermaid.parseError);\n    }\n  }\n  if (errors.length > 0) {\n    throw errors[0];\n  }\n};\nconst initialize = function (config) {\n  mermaidAPI.initialize(config);\n};\nconst init = async function (config, nodes, callback) {\n  log.warn(\"mermaid.init is deprecated. Please use run instead.\");\n  if (config) {\n    initialize(config);\n  }\n  const runOptions = {\n    postRenderCallback: callback,\n    querySelector: \".mermaid\"\n  };\n  if (typeof nodes === \"string\") {\n    runOptions.querySelector = nodes;\n  } else if (nodes) {\n    if (nodes instanceof HTMLElement) {\n      runOptions.nodes = [nodes];\n    } else {\n      runOptions.nodes = nodes;\n    }\n  }\n  await run(runOptions);\n};\nconst registerExternalDiagrams = async (diagrams, {\n  lazyLoad = true\n} = {}) => {\n  registerLazyLoadedDiagrams(...diagrams);\n  if (lazyLoad === false) {\n    await loadRegisteredDiagrams();\n  }\n};\nconst contentLoaded = function () {\n  if (mermaid.startOnLoad) {\n    const {\n      startOnLoad\n    } = mermaidAPI.getConfig();\n    if (startOnLoad) {\n      mermaid.run().catch(err => log.error(\"Mermaid failed to initialize\", err));\n    }\n  }\n};\nif (typeof document !== \"undefined\") {\n  /*!\n   * Wait for document loaded before starting the execution\n   */\n  window.addEventListener(\"load\", contentLoaded, false);\n}\nconst setParseErrorHandler = function (parseErrorHandler) {\n  mermaid.parseError = parseErrorHandler;\n};\nconst executionQueue = [];\nlet executionQueueRunning = false;\nconst executeQueue = async () => {\n  if (executionQueueRunning) {\n    return;\n  }\n  executionQueueRunning = true;\n  while (executionQueue.length > 0) {\n    const f = executionQueue.shift();\n    if (f) {\n      try {\n        await f();\n      } catch (e) {\n        log.error(\"Error executing queue\", e);\n      }\n    }\n  }\n  executionQueueRunning = false;\n};\nconst parse = async (text, parseOptions) => {\n  return new Promise((resolve, reject) => {\n    const performCall = () => new Promise((res, rej) => {\n      mermaidAPI.parse(text, parseOptions).then(r => {\n        res(r);\n        resolve(r);\n      }, e => {\n        var _a;\n        log.error(\"Error parsing\", e);\n        (_a = mermaid.parseError) == null ? void 0 : _a.call(mermaid, e);\n        rej(e);\n        reject(e);\n      });\n    });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\nconst render = (id, text, container) => {\n  return new Promise((resolve, reject) => {\n    const performCall = () => new Promise((res, rej) => {\n      mermaidAPI.render(id, text, container).then(r => {\n        res(r);\n        resolve(r);\n      }, e => {\n        var _a;\n        log.error(\"Error parsing\", e);\n        (_a = mermaid.parseError) == null ? void 0 : _a.call(mermaid, e);\n        rej(e);\n        reject(e);\n      });\n    });\n    executionQueue.push(performCall);\n    executeQueue().catch(reject);\n  });\n};\nconst mermaid = {\n  startOnLoad: true,\n  mermaidAPI,\n  parse,\n  render,\n  init,\n  run,\n  registerExternalDiagrams,\n  initialize,\n  parseError: void 0,\n  contentLoaded,\n  setParseErrorHandler\n};\nexport { mermaid as default };","map":null,"metadata":{},"sourceType":"module"}