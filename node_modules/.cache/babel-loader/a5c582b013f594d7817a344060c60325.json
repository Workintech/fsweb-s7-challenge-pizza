{"ast":null,"code":"/* IMPORT */\nimport _ from '../utils/index.js';\nimport ChannelsReusable from '../channels/reusable.js';\nimport { DEC2HEX } from '../constants.js';\n/* MAIN */\nvar Hex = {\n  /* VARIABLES */\n  re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,\n  /* API */\n  parse: function parse(color) {\n    if (color.charCodeAt(0) !== 35) return; // '#'\n    var match = color.match(Hex.re);\n    if (!match) return;\n    var hex = match[1];\n    var dec = parseInt(hex, 16);\n    var length = hex.length;\n    var hasAlpha = length % 4 === 0;\n    var isFullLength = length > 4;\n    var multiplier = isFullLength ? 1 : 17;\n    var bits = isFullLength ? 8 : 4;\n    var bitsOffset = hasAlpha ? 0 : -1;\n    var mask = isFullLength ? 255 : 15;\n    return ChannelsReusable.set({\n      r: (dec >> bits * (bitsOffset + 3) & mask) * multiplier,\n      g: (dec >> bits * (bitsOffset + 2) & mask) * multiplier,\n      b: (dec >> bits * (bitsOffset + 1) & mask) * multiplier,\n      a: hasAlpha ? (dec & mask) * multiplier / 255 : 1\n    }, color);\n  },\n  stringify: function stringify(channels) {\n    var r = channels.r,\n      g = channels.g,\n      b = channels.b,\n      a = channels.a;\n    if (a < 1) {\n      // #RRGGBBAA\n      return \"#\".concat(DEC2HEX[Math.round(r)]).concat(DEC2HEX[Math.round(g)]).concat(DEC2HEX[Math.round(b)]).concat(DEC2HEX[Math.round(a * 255)]);\n    } else {\n      // #RRGGBB\n      return \"#\".concat(DEC2HEX[Math.round(r)]).concat(DEC2HEX[Math.round(g)]).concat(DEC2HEX[Math.round(b)]);\n    }\n  }\n};\n/* EXPORT */\nexport default Hex;","map":null,"metadata":{},"sourceType":"module"}